<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java五子棋一</title>
    <link href="/2022/05/19/Java%E4%BA%94%E5%AD%90%E6%A3%8B%E4%B8%80/"/>
    <url>/2022/05/19/Java%E4%BA%94%E5%AD%90%E6%A3%8B%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="五子棋"><a href="#五子棋" class="headerlink" title="五子棋"></a>五子棋</h1><p>今天来开发一个简单的五子棋游戏，我们需要实现以下这些功能：</p><ul><li>下棋</li><li>判断胜负</li><li>悔棋</li><li>人机模式</li></ul><p>接下来分不同的章节来对这些功能的实现进行讲解。</p><h2 id="下棋功能实现"><a href="#下棋功能实现" class="headerlink" title="下棋功能实现"></a>下棋功能实现</h2><h3 id="一-界面"><a href="#一-界面" class="headerlink" title="一 界面"></a>一 界面</h3><p>下棋我们首先应该创建一个界面，在这个界面上下棋，我们可以使用<code>Java</code>的<code>GUI</code>库来实现这个界面，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showUI</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;五子棋&quot;</span>);<br>       frame.setSize(<span class="hljs-number">1200</span>,<span class="hljs-number">900</span>);<br>       frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>       frame.setLocationRelativeTo(<span class="hljs-literal">null</span>);<br><br>       <span class="hljs-type">MyJPanel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyJPanel</span>();<br>       frame.add(panel, BorderLayout.CENTER);<br>       <span class="hljs-type">JPanel</span> <span class="hljs-variable">jPanel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>();<br>       jPanel.setPreferredSize(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dimension</span>(<span class="hljs-number">250</span>,<span class="hljs-number">80</span>));<br>       jPanel.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());<br>       String[] btname = &#123;<span class="hljs-string">&quot;开始&quot;</span>,<span class="hljs-string">&quot;悔棋&quot;</span>,<span class="hljs-string">&quot;重新开始&quot;</span>,<span class="hljs-string">&quot;人机模式&quot;</span>&#125;;<br>       <span class="hljs-type">Mouse</span> <span class="hljs-variable">mouse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mouse</span>();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; btname.length;i++)<br>       &#123;<br>           <span class="hljs-type">JButton</span> <span class="hljs-variable">bt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(btname[i]);<br>           bt.setPreferredSize(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dimension</span>(<span class="hljs-number">200</span>,<span class="hljs-number">80</span>));<br>           bt.addActionListener(mouse);<br>           jPanel.add(bt);<br>       &#125;<br><br>       frame.add(jPanel,BorderLayout.EAST);<br>       frame.setVisible(<span class="hljs-literal">true</span>);<br><br>       <span class="hljs-type">Graphics</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> panel.getGraphics();<br>       mouse.setg(g);<br>       mouse.setPanel(panel);<br>       panel.addMouseListener(mouse);<br>       panel.setchessArr(mouse.getChessArr());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用<code>JFrame</code>创建了一个窗体，使用<code>JPanel</code>给这个窗体设置了两个分区，分别存放棋盘和功能按钮，同时对棋盘和按钮添加监听器，这样可以监听到我们鼠标点击了哪个区域，运行效果如下：</p><p><img src="/Java%E4%BA%94%E5%AD%90%E6%A3%8B%E4%B8%80/image-20220519234024188.png" alt="image-20220519234024188"></p><p>其实进运行上述代码并不能出现棋盘，由于笔者已经开发完毕，就没有分开展示不同代码的功能，接下来讲解如何绘制棋盘。</p><h3 id="二-棋盘"><a href="#二-棋盘" class="headerlink" title="二 棋盘"></a>二 棋盘</h3><p>其实可以看到上述代码并不涉及棋盘的绘制的，我的棋盘绘制写在了<code>MyJPanel</code>这个<code>class</code>里，<code>MyJPanel</code>这个<code>class</code>继承了<code>JPanel</code>。为什么这里不直接使用<code>JPanel</code>是因为在我们每次拖拽界面时，<code>Java</code>都会调用<code>JPanel</code>中的<code>paint</code>方法对界面进行重绘，界面上的内容就会消失，我们所绘制的棋盘也就消失了，因此我们要将<code>paint</code>方法重写，在每次调用<code>paint</code>方法时对我们的棋盘进行重绘。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;<br>    <span class="hljs-built_in">super</span>.paint(g);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; LINE; i++) &#123;<br>        g.drawLine(X0, Y0 + i * SIZE, X0 + (LINE - <span class="hljs-number">1</span>) * SIZE, Y0 + i * SIZE);<br>        g.drawLine(X0 + i * SIZE, Y0, X0 + i * SIZE, Y0 + (LINE - <span class="hljs-number">1</span>) * SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中<code>for</code>循环里的<code>LINE</code>是定义在<code>Config</code>这个接口里，我们写代码时要尽量避免硬编码，我们可以将一些参数定义在接口里进行调用。<code>Config</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Config</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">X0</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">Y0</span> <span class="hljs-operator">=</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LINE</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CHESS</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RULE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>X0,Y0</code>代表我们棋盘起始点的坐标，<code>SIZE</code>代表棋盘每个格子的间距<code>LINE</code>代表我们要画多少根线。</p><h3 id="三-下棋"><a href="#三-下棋" class="headerlink" title="三 下棋"></a>三 下棋</h3><p>我们有了棋盘，接下来就是下棋功能的实现了。</p><p>在上面<strong>界面</strong>部分的代码中，我们可以看到有<code>Mouse</code>这个类，这个类继承了<code>MouseAdapter</code>，实现了<code>ActionListener</code>这个接口，我们需要使用这个类来来监听鼠标做了哪些事，<code>ActionListener</code>为按钮的监听器，我们可以看一下<code>ActionListener</code>和<code>MouseAdapter</code>的代码。</p><h4 id="ActionListener"><a href="#ActionListener" class="headerlink" title="ActionListener"></a>ActionListener</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> java.awt.event;<br><br><span class="hljs-keyword">import</span> java.util.EventListener;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ActionListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventListener</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Invoked when an action occurs.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="MouseAdapter"><a href="#MouseAdapter" class="headerlink" title="MouseAdapter"></a>MouseAdapter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MouseAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MouseListener</span>, MouseWheelListener, MouseMotionListener &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseClicked</span><span class="hljs-params">(MouseEvent e)</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mousePressed</span><span class="hljs-params">(MouseEvent e)</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseReleased</span><span class="hljs-params">(MouseEvent e)</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseEntered</span><span class="hljs-params">(MouseEvent e)</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseExited</span><span class="hljs-params">(MouseEvent e)</span> &#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.6</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseWheelMoved</span><span class="hljs-params">(MouseWheelEvent e)</span>&#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.6</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseDragged</span><span class="hljs-params">(MouseEvent e)</span>&#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.6</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseMoved</span><span class="hljs-params">(MouseEvent e)</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们仅需要监听鼠标点击这一事件，因此我们只需要重写<code>MouseAdapter</code>中<code>mouseClick</code>这一方法即可。</p><h4 id="下棋"><a href="#下棋" class="headerlink" title="下棋"></a>下棋</h4><p>下棋这里我封装<code>drawChess</code>这个方法，我们知道我们点击棋盘上任何位置都会有一个坐标，但是我们的棋子必须落在棋盘的交点上，因此我们需要对坐标进行计算，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawChess</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">if</span> ((x - X0) % SIZE &gt; SIZE / <span class="hljs-number">2</span>) &#123;<br>        X = (x - X0) / SIZE + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        X = (x - X0) / SIZE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((y - Y0) % SIZE &gt; SIZE / <span class="hljs-number">2</span>) &#123;<br>        Y = (y - Y0) / SIZE + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Y = (y - Y0) / SIZE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-literal">true</span> &amp;&amp; chessArr[X][Y] == <span class="hljs-number">0</span>) &#123;<br>        g.setColor(Color.black);<br>        chessArr[X][Y] = <span class="hljs-number">1</span>;<br>        count = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-literal">false</span> &amp;&amp; chessArr[X][Y] == <span class="hljs-number">0</span>) &#123;<br>        g.setColor(Color.white);<br>        chessArr[X][Y] = <span class="hljs-number">2</span>;<br>        count = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    g.fillOval(X * SIZE + X0 - CHESS / <span class="hljs-number">2</span>, Y * SIZE + Y0 - CHESS / <span class="hljs-number">2</span>, CHESS, CHESS);<br>&#125;<br></code></pre></td></tr></table></figure><p>计算交点的逻辑很简单，首先我们传入当前鼠标点击位置的坐标<code>x,y</code>，计算他们和界面左上角坐标<code>X0,Y0</code>之间的距离除以<code>SIZE</code>，如果超过了<code>SIZE</code>的一半，那就对距离进行+1，没超过则保持不变。同时我们设置了一个二维数组来保存棋子落下的位置，黑棋记为”1“，白棋记为”2“，没有落子的部分为”0“。通过<code>count</code>这个布尔变量来切换棋子的颜色。接下来我们在<code>mouseClicked</code>中调用此方法，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void mouse<span class="hljs-constructor">Clicked(MouseEvent <span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> x = e.get<span class="hljs-constructor">X()</span>;<br>        <span class="hljs-built_in">int</span> y = e.get<span class="hljs-constructor">Y()</span>;<br>        draw<span class="hljs-constructor">Chess(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>每次我们鼠标点击获取当前坐标，传入<code>drawChess</code>方法中进行绘制，现在我们就可以下棋了。运行效果如下：</p><p><img src="/Java%E4%BA%94%E5%AD%90%E6%A3%8B%E4%B8%80/image-20220520001609186.png" alt="image-20220520001609186"></p><h4 id="棋子重绘"><a href="#棋子重绘" class="headerlink" title="棋子重绘"></a>棋子重绘</h4><p>我们在下棋时已经将棋子存在了一个二维数组中，我们将这个数组传入<code>MyJPanel</code>这个类中，重写<code>paint</code>方法对棋子进行重绘。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;i&lt;chessArr.length;i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;chessArr.length;j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(chessArr[i][j]==<span class="hljs-number">1</span>)<br>        &#123;<br>            g.setColor(Color.black);<br>            g.fillOval(i*SIZE+X0-CHESS/<span class="hljs-number">2</span>,j*SIZE+Y0-CHESS/<span class="hljs-number">2</span>,CHESS,CHESS);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(chessArr[i][j]==<span class="hljs-number">2</span>)<br>        &#123;<br>            g.setColor(Color.white);<br>            g.fillOval(i*SIZE+X0-CHESS/<span class="hljs-number">2</span>,j*SIZE+Y0-CHESS/<span class="hljs-number">2</span>,CHESS,CHESS);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="判断胜负"><a href="#判断胜负" class="headerlink" title="判断胜负"></a>判断胜负</h2><h3 id="一-实现逻辑"><a href="#一-实现逻辑" class="headerlink" title="一 实现逻辑"></a>一 实现逻辑</h3><p>当我们下一枚棋子，我们就遍历当前棋子坐标上下左右斜线这些方向有没有与他相同颜色的棋子，计算数量判断是否等于5。</p><h3 id="二-具体实现"><a href="#二-具体实现" class="headerlink" title="二 具体实现"></a>二 具体实现</h3><p>在我们下棋时已经将棋子存入了二维数组中，对当前棋子八个方向（左，右，上，下，右斜向上，右斜向下，左斜向上，左斜向下）进行遍历，计算同色棋子数量判断胜负。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> y; i &lt; chessArr.length; i++) &#123;<br>           <span class="hljs-keyword">if</span> (chessArr[x][y] == chessArr[x][i]) &#123;<br>               num++;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> y - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>           <span class="hljs-keyword">if</span> (chessArr[x][y] == chessArr[x][i]) &#123;<br>               num++;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">5</span>) &#123;<br>           num = <span class="hljs-number">0</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><p>由于篇幅原因，这里只展示了判断上下两个方向的代码，读者可以自行拓展。现在我们就可以判断胜负了，运行效果如下：</p><p><img src="/Java%E4%BA%94%E5%AD%90%E6%A3%8B%E4%B8%80/image-20220520002732926.png" alt="image-20220520002732926"></p><h2 id="悔棋"><a href="#悔棋" class="headerlink" title="悔棋"></a>悔棋</h2><h3 id="一-实现逻辑-1"><a href="#一-实现逻辑-1" class="headerlink" title="一 实现逻辑"></a>一 实现逻辑</h3><p>悔棋我们只需要将最后一次下棋的棋子删除即可。</p><h3 id="二-具体实现-1"><a href="#二-具体实现-1" class="headerlink" title="二 具体实现"></a>二 具体实现</h3><p>我们需要定义一个<code>Chess</code>类来记录我们每一个棋子的坐标，将二维数组对应位置的元素设置为0，并对棋盘重绘即可。</p><h4 id="Chess类代码如下"><a href="#Chess类代码如下" class="headerlink" title="Chess类代码如下"></a><code>Chess</code>类代码如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chess</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> chessX,chessY;<br>    <span class="hljs-keyword">public</span> Color color;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> count;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chess</span><span class="hljs-params">(<span class="hljs-type">int</span> chessX,<span class="hljs-type">int</span> chessY,<span class="hljs-type">boolean</span> count,Color color)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.chessX = chessX;<br>        <span class="hljs-built_in">this</span>.chessY = chessY;<br>        <span class="hljs-built_in">this</span>.color = color;<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="悔棋功能代码如下"><a href="#悔棋功能代码如下" class="headerlink" title="悔棋功能代码如下"></a>悔棋功能代码如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> &#123;<br>        btnText = e.getActionCommand();<br><br>        <span class="hljs-keyword">if</span> (btnText.equals(<span class="hljs-string">&quot;悔棋&quot;</span>)) &#123;<br>            <span class="hljs-type">Chess</span> <span class="hljs-variable">chess</span> <span class="hljs-operator">=</span> chessList.get(chessList.size() - <span class="hljs-number">1</span>);<br>            chessArr[chess.chessX][chess.chessY] = <span class="hljs-number">0</span>;<br>            count = !chess.count;<br>            panel.paint(g);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>这里我们获取当前点击按钮的内容，若为悔棋则运行下面的代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>进行到这里，基本的功能就已经实现了。下一部分讲人机对战。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>五子棋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类与装饰器</title>
    <link href="/2022/05/18/%E7%B1%BB%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2022/05/18/%E7%B1%BB%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="类与装饰器"><a href="#类与装饰器" class="headerlink" title="类与装饰器"></a>类与装饰器</h2><p>之前写过有关装饰器的博客，但是没有涉及类装饰器，类装饰器到底是装饰类的装饰器还是类作为装饰器呢？</p><h3 id="类作为装饰器"><a href="#类作为装饰器" class="headerlink" title="类作为装饰器"></a>类作为装饰器</h3><h4 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h4><p>在了解类作为装饰器之前，首先要了解一下call方法，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是<span class="hljs-subst">&#123;self.name&#125;</span>&#x27;</span>)<br><br><br>p = Person(<span class="hljs-string">&#x27;chy&#x27;</span>)<br>p()<br></code></pre></td></tr></table></figure><p>我们在创建一个类时，写了<code>__call__</code>方法，可以让我们实例化出来的对象时<code>callable</code>的，也就是可以像方法一样调用。运行结果如下：</p><p><img src="/%E7%B1%BB%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/1.jpg"></p><h4 id="类作为装饰器-1"><a href="#类作为装饰器-1" class="headerlink" title="类作为装饰器"></a>类作为装饰器</h4><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        start = time.time()<br>        ret = self.func(*args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Time: <span class="hljs-subst">&#123;time.time() - start&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> ret<br><br><br><span class="hljs-meta">@Timer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="/%E7%B1%BB%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/2.jpg"></p><p>可能我们难以理解，但是有这个万能公式一切都好理解了，我们要关注<code>@Timer</code>到底做了什么，在一个函数上做装饰器，就等于装饰器调用这个函数，也就相当于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">add = Timer(add)<br></code></pre></td></tr></table></figure><p>这相当于把<code>add</code>这个函数转换成了<code>Timer</code>类的对象，<code>add</code>函数作为一个参数转移到了<code>self.func</code>里。其实与函数装饰器没有什么区别。</p><h4 id="类作为装饰器含参数"><a href="#类作为装饰器含参数" class="headerlink" title="类作为装饰器含参数"></a>类作为装饰器含参数</h4><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, prefix</span>):<br>        self.prefix = prefix<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            start = time.time()<br><br>            ret = func(*args, **kwargs)<br>            end = time.time()<br><br>            <span class="hljs-built_in">print</span>(self.prefix, (end - start))<br>            <span class="hljs-keyword">return</span> ret<br><br>        <span class="hljs-keyword">return</span> wrapper<br>    <br><span class="hljs-meta">@Timer(<span class="hljs-params">prefix=<span class="hljs-string">&quot;curr_time:&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><br><span class="hljs-built_in">print</span>(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><br><br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E7%B1%BB%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/3.jpg"></p><p>上面的代码等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">add = Timer(prefix=<span class="hljs-string">&quot;curr_time&quot;</span>)(add)<br></code></pre></td></tr></table></figure><h3 id="装饰类的装饰器"><a href="#装饰类的装饰器" class="headerlink" title="装饰类的装饰器"></a>装饰类的装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_str</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.__dict__)<br><br>    cls.__str__ = __str__<br>    <span class="hljs-keyword">return</span> cls<br><br><br><span class="hljs-meta">@add_str</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b</span>):<br>        self.a = a<br>        self.b = b<br><br><br>o = MyObject(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(o)<br></code></pre></td></tr></table></figure><p>我们知道可以通过重写<code>__str__</code>方法改变打印一个实例对象的输出，上面的<code>add_str</code>函数就做了这样的事，运行结果如下：</p><p><img src="/%E7%B1%BB%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/4.jpg"></p><p>可能它不好理解，但是转换成等价形式就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MyObject = add_str(MyObject)<br></code></pre></td></tr></table></figure><p>理解了这个，其实装饰类的装饰器也没什么难的，就是输入一个类在这个类上进行操作再返回这个类罢了。</p><p>当然这个装饰器也可以添加参数，转换成等价形式就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">MyObject = add_str(prefix)(MyObject)<br></code></pre></td></tr></table></figure><p>我们对上面的代码进行改写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_str</span>(<span class="hljs-params">prefix</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self.__dict__)<br><br>        cls.__str__ = __str__<br>        <span class="hljs-built_in">print</span>(prefix)<br>        <span class="hljs-keyword">return</span> cls<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-meta">@add_str(<span class="hljs-params">prefix=<span class="hljs-number">123</span></span>)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, a, b</span>):<br>        self.a = a<br>        self.b = b<br><br><br>o = MyObject(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(o)<br></code></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="/%E7%B1%BB%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/5.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>没什么好总结的，之前在《cookbook》里没看懂的东西现在应该都看的懂了。</p>]]></content>
    
    
    <categories>
      
      <category>python高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>装饰器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python的hash机制</title>
    <link href="/2022/05/17/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/05/17/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设我们有如下场景：</p><p>我们在玩一个二维游戏，我们想知道一个坐标上站了多少玩家</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Position</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x;<br>        self.y = y;<br><br><br>pos = Position(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>pos2 = Position(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(pos), <span class="hljs-built_in">id</span>(pos2))<br>d = &#123;&#125;<br>d[pos] = <span class="hljs-number">1</span><br>d[pos2] = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(d)<br></code></pre></td></tr></table></figure><p>理所当然我们会设置如上的代码，使用一个Position类来设置坐标，使用一个字典来保存对应坐标的人数，此时我们希望<code>pos</code>和<code>pos2</code>在字典中对应的键是一样的，但是实际结果是这样吗？</p><p>运行结果：</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/1.png"></p><p>可以看到我们并没有将键值更改，而是字典中存在了两个键分别对应不同的键值，这并不是我们期望的结果，通过打印对象<code>id</code>我们可以知道两个实例对象的<code>id</code>并不相同，因此字典并不认为他们相同。针对此问题我们如何解决呢？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我们理所当然的会想到，我们可以重写<code>Position</code>类中的<code>__eq__</code>函数让两个对象相等，因此我们对代码做出如下修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Position</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x;<br>        self.y = y;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.x == other.x <span class="hljs-keyword">and</span> self.y == other.y<br><br><br>pos = Position(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>pos2 = Position(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(pos==pos2)<br><br>d = &#123;&#125;<br>d[pos] = <span class="hljs-number">1</span><br>d[pos2] = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(d)<br></code></pre></td></tr></table></figure><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/2.png"></p><p>可以看到此时两个对象确实相等，但是却报错了，为什么我们不加<code>__eq__</code>函数没报错，加了反而报错了呢?</p><h2 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h2><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/3.png"></p><p>这里就是我们在给一个字典设置插入数据时使用的方法，他返回一个函数我们点到<code>_PyDict_SetItem_Take2</code>里进行查看</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/4.png"></p><p>在这里可以看到如果这个<code>key</code>不是一个<code>unicode</code>的话就会进入<code>PyObject_Hash</code>里取一个哈希值，我们再进入<code>PyObject_Hash</code>进行查看</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/5.png"></p><p>这个函数并不难，如果有hash方法则返回一个hash值，如果没有则报异常我们再进入这个异常中看一下</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/6.png"></p><p>在这里我们看到了我们代码中报的错误，也就是说当一个<code>object</code>没有<code>hashfunction</code>时，如果我们想要将其作为字典中的<code>key</code>就会报<code>unhashable type:</code>，但是当我们没有设置<code>__eq__</code>时我们并不会报错，也就是说我们的对象是<code>hashable</code>的，但是我们设置了却发生了错误，这中间发生了什么？</p><p>我们再回到<code>PyObject_Hash</code>函数中</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/5.png"></p><p>这里<code>tp_hash</code>是一个函数指针，就是当他想求一个<code>hash</code>函数时，所用的到指针</p><ul><li>第一个问题：为什么我们没有在类里设置<code>hash</code>函数，它可以作为字典的<code>key</code></li><li>第二个问题：为什么我们在类里设置<code>__eq__</code>时会报错？</li></ul><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>其实，我们理所当然可以想到，在我们定义一个类时会自动继承基类<code>Object</code>，这里是有一个默认的<code>hash</code>函数的，在源码中我们也可以看到</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/7.png"></p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/8.png"></p><p>实际上就是使用基类的<code>hash</code>方法对这个对象的地址进行了<code>hash</code>操作，因为我们每个对象的<code>id</code>也就是地址是不同的，所以对应字典中两个<code>key</code>，那么为什么我们在定义<code>__eq__</code>后会报错呢？如下图所示</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/9.png"></p><p>这里的代码是当我们定义一个类是会继承多少基类中的方法，我们可以看到当我们<code>type-&gt;tp_richcompare == NULL &amp;&amp; type-&gt;tp_hash == NULL</code>与我们没有重写<code>hash</code>时才会继承基类的<code>richcompare</code>与<code>hash</code>，但是我们并没有重写基类的<code>hash</code>方法。我们点开<code>overrides_hash</code>函数</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/10.png"></p><p>如上图所示，现在我们就很清晰了，只要我们重写了<code>__eq__</code>就相当于我们重写了<code>hash</code>，也就是说由于我们重写了<code>__eq__</code>，导致我们没有继承基类的<code>hash</code>函数，也就导致我们无法把这个对象作为<code>dict</code>里的一个<code>key</code>。</p><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>因此此时我们只需要在这个类里实现<code>hash</code>函数，我们就可以解决这一问题</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Position</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x;<br>        self.y = y;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>(self.x, self.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> self.x == other.x <span class="hljs-keyword">and</span> self.y == other.y<br><br><br>pos = Position(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>pos2 = Position(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(pos == pos2)<br><br>d = &#123;&#125;<br>d[pos] = <span class="hljs-number">1</span><br>d[pos2] = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(d)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/11.png"></p><p>我们得到了我们想要的结果</p><p>这里我们已经实现了<code>hash</code>，那如果我们不要<code>__eq__</code>呢？</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Position</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x;<br>        self.y = y;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>((self.x, self.y))<br><br><br><br><br>pos = Position(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>pos2 = Position(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(pos == pos2)<br><br>d = &#123;&#125;<br>d[pos] = <span class="hljs-number">1</span><br>d[pos2] = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(d)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/12.png"></p><p>这里又变成了两个<code>key</code>，其实这很好理解，两个值一样的数据它可能会有相同的<code>hash</code>值，这也就是<code>Hash collision</code>（哈希碰撞），在我们没有定义<code>__eq__</code>时它不仅比较两个对象的<code>hash</code>值同时比较两个对象的<code>id</code>，我们知道两个对象的<code>id</code>是不同的，所以<code>dict</code>并不会认为这两个对象代表同一个<code>key</code>。</p><p>说到这里，我们可能会认为如果两个对象有相同的<code>hash</code>，并且<code>eq</code>他就是一个<code>key</code>，如果仅有相同的<code>hash</code>但是并不<code>eq</code>那就是两个<code>key</code>。真的是这样吗？再看下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Position</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x, y</span>):<br>        self.x = x;<br>        self.y = y;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__hash__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>((self.x, self.y))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br>pos = Position(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>pos2 = pos<br><span class="hljs-built_in">print</span>(pos == pos2)<br><br>d = &#123;&#125;<br>d[pos] = <span class="hljs-number">1</span><br>d[pos2] = <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(d)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/13.png"></p><p>这里<code>eq</code>永远返回<code>False</code>，这意味着不管两个对象是否真的<code>eq</code>我们都认为他是不相等的，同时我们将<code>pos</code>直接赋值给了<code>pos</code>，在python中一切皆引用，此时他们的<code>id</code>是相同的，我们打印它们是否相等，结果却是不相等，但是<code>dict</code>认为它们是同一个<code>key</code>。这又是为什么呢？我们再回到源码中</p><p><img src="/python%E7%9A%84hash%E6%9C%BA%E5%88%B6/14.png"></p><p>这里其实比较的是新的<code>key</code>和原来hash位置相同的<code>key</code>是否是相等的，这里是C语言中的相等，也就是这两个地址是否相同，若相同则不会比较后面的<code>hash</code>值以及<code>eq</code>，这也就解释了上述代码的结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自定义类型做<code>dict</code>的<code>key</code>，必须要有<code>__hash__</code>方法，<code>dict</code>判断两个<code>key</code>是不是同一个<code>key</code>时，优先比较这两个<code>key</code>的<code>id</code>，若<code>id</code>相同则认为是一个<code>key</code>，若<code>id</code>不同则比较<code>__hash__</code>和<code>__eq__</code>，且两者同时相等才认为是同一个<code>key</code>。</p><p>学习python的时候觉得很简单，但是深入进去却发现很难也很有趣。</p>]]></content>
    
    
    <categories>
      
      <category>python高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装饰器</title>
    <link href="/2022/05/04/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2022/05/04/%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h2><p>看如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_10w</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算100000以内的每个数的立方和</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    sum_ret = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100001</span>):<br>        sum_ret += i ** <span class="hljs-number">3</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;10w以内的每个数的立方和为：&quot;</span>, sum_ret)<br><br><br>start_time = time.time()<br>calculate_10w()<br>stop_time = time.time()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;耗费总时长为:&quot;</span>, stop_time - start_time, <span class="hljs-string">&quot;（秒）&quot;</span>)<br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/1.png"></p><p>问题：</p><blockquote><p>如果现在需要对5个函数都要进行耗时统计，请问怎样实现？难道将上图中的15、17、19行 写5遍吗？</p></blockquote><p>为了解决类似的问题，我们需要学习一个新的知识：装饰器</p><p>提醒：</p><blockquote><p>装饰器很重要，一定要学会</p><p>装饰器是程序开发中经常会用到的一个功能，用好了装饰器，开发效率如虎添翼，所以这也是Python面试中必问的问题，但对于好多初次接触这个知识的人来讲，这个功能有点绕，自学时直接绕过去了，然后面试问到了就挂了，因为装饰器是程序开发的基础知识，这个都不会，别跟人家说你会Python, 看了下面的文章，保证你学会装饰器。</p></blockquote><h2 id="2-知识准备"><a href="#2-知识准备" class="headerlink" title="2. 知识准备"></a>2. 知识准备</h2><h3 id="2-1-引用"><a href="#2-1-引用" class="headerlink" title="2.1 引用"></a>2.1 引用</h3><p>测试代码1（定义函数、调用函数、函数名是函数引用）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#### 第一波 ####</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br> <br>foo  <span class="hljs-comment"># 表示是函数</span><br>foo()  <span class="hljs-comment"># 表示调用foo函数</span><br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>测试代码2（多个函数用同一个函数名，会导致前面的定义的代码块不能被调用）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#### 第二波 ####</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br> <br>foo = <span class="hljs-keyword">lambda</span> x: x + <span class="hljs-number">1</span><br> <br>foo()  <span class="hljs-comment"># 执行lambda表达式，而不再是原来的foo函数，因为foo这个名字被重新指向了另外一个匿名函数复制Error复制成功...</span><br></code></pre></td></tr></table></figure><p>函数名仅仅是个变量，只不过指向了定义的函数而已，所以才能通过 <code>函数名()</code>调用，如果 <code>函数名=xxx</code>被修改了，那么当在执行<code>函数名()</code>时，调用的就不是之前的那个函数了</p><h3 id="2-2-闭包"><a href="#2-2-闭包" class="headerlink" title="2.2 闭包"></a>2.2 闭包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_pencil</span>(<span class="hljs-params">color</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">content</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在使用(%s)色，写：%s&quot;</span> % (color, content))<br><br>    <span class="hljs-keyword">return</span> write<br><br><br>black_pencil = make_pencil(<span class="hljs-string">&quot;黑&quot;</span>)<br>black_pencil(<span class="hljs-string">&quot;我是喝墨水长大的&quot;</span>)<br><br>red_pencil = make_pencil(<span class="hljs-string">&quot;红&quot;</span>)<br>red_pencil(<span class="hljs-string">&quot;这么巧，我也是，只不过是红墨水&quot;</span>)<br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/2.png"></p><p>小复习：</p><blockquote><p>闭包用到的核心其实就是：在一个函数中返回另外一个函数的引用，只不过这个被返回的函数中用到了其他函数中的变量而已。说到底就是 只要用一个变量指向某个函数代码块，就可以调用它</p></blockquote><h2 id="3-引入装饰器"><a href="#3-引入装饰器" class="headerlink" title="3. 引入装饰器"></a>3. 引入装饰器</h2><h3 id="3-1-问题"><a href="#3-1-问题" class="headerlink" title="3.1 问题"></a>3.1 问题</h3><p>初创公司有N个业务部门，基础平台部门负责提供底层的功能，如：</p><ul><li>数据库操作</li><li>Redis调用</li><li>监控API等功能</li></ul><p>其他业务部门使用基础功能时，只需调用基础平台提供的功能即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">############### 基础平台提供的功能如下 ###############</span><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f1&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f2&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f3</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f3&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f4</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f4&#x27;</span>)<br> <br><span class="hljs-comment">############### 业务部门A 调用基础平台提供的功能 ###############</span><br>f1()<br>f2()<br>f3()<br>f4()<br> <br><span class="hljs-comment">############### 业务部门B 调用基础平台提供的功能 ###############</span><br>f1()<br>f2()<br>f3()<br>f4()复制Error复制成功...<br></code></pre></td></tr></table></figure><p>目前公司有条不紊的进行着，但是以前基础平台的开发人员在写代码时候没有关注<code>验证权限</code>相关的问题，</p><p>即：基础平台的提供的功能现在是可以被任何人使用。这种做法肯定是不妥的，因为这样会容易泄露功能代码</p><p>现在需要对基础平台的所有功能进行重构，为平台提供的所有功能添加验证机制，</p><p>即：执行功能前，先进行验证</p><p>想想，如果是你接手这个任务，你会怎么做呢？</p><h3 id="3-2-尝试解决问题"><a href="#3-2-尝试解决问题" class="headerlink" title="3.2 尝试解决问题"></a>3.2 尝试解决问题</h3><h4 id="3-2-1-老大把工作交给-Low-B"><a href="#3-2-1-老大把工作交给-Low-B" class="headerlink" title="3.2.1 老大把工作交给 Low B"></a>3.2.1 老大把工作交给 Low B</h4><p>他是这么做的：</p><blockquote><p>跟每个业务部门交涉，每个业务部门自己写代码，调用基础平台的功能之前先验证。哎！这样一来基础平台就不需要做任何修改了。太棒了，有充足的时间泡妹子…</p></blockquote><p>当天Low B 被开除了…</p><h4 id="3-2-2-老大把工作交给-Low-BB"><a href="#3-2-2-老大把工作交给-Low-BB" class="headerlink" title="3.2.2 老大把工作交给 Low BB"></a>3.2.2 老大把工作交给 Low BB</h4><p>他是这么做的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">############### 基础平台提供的功能如下 ############### </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-comment"># 验证1</span><br>    <span class="hljs-comment"># 验证2</span><br>    <span class="hljs-comment"># 验证3</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f1&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>():<br>    <span class="hljs-comment"># 验证1</span><br>    <span class="hljs-comment"># 验证2</span><br>    <span class="hljs-comment"># 验证3</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f2&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f3</span>():<br>    <span class="hljs-comment"># 验证1</span><br>    <span class="hljs-comment"># 验证2</span><br>    <span class="hljs-comment"># 验证3</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f3&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f4</span>():<br>    <span class="hljs-comment"># 验证1</span><br>    <span class="hljs-comment"># 验证2</span><br>    <span class="hljs-comment"># 验证3</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f4&#x27;</span>)<br> <br><span class="hljs-comment">### 业务部门A 调用基础平台提供的功能### </span><br>f1()<br>f2()<br>f3()<br>f4()<br> <br><span class="hljs-comment">### 业务部门B 调用基础平台提供的功能 ### </span><br> <br>f1()<br>f2()<br>f3()<br>f4()复制Error复制成功...<br></code></pre></td></tr></table></figure><p>过了一周 Low BB 被开除了…</p><h4 id="3-2-3-老大把工作交给-Low-BBB"><a href="#3-2-3-老大把工作交给-Low-BBB" class="headerlink" title="3.2.3 老大把工作交给 Low BBB"></a>3.2.3 老大把工作交给 Low BBB</h4><p>他是这么做的：</p><blockquote><p>只对基础平台的代码进行重构，其他业务部门无需做任何修改</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">############### 基础平台提供的功能如下 ############### </span><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_login</span>():<br>    <span class="hljs-comment"># 验证1</span><br>    <span class="hljs-comment"># 验证2</span><br>    <span class="hljs-comment"># 验证3</span><br>    <span class="hljs-keyword">pass</span><br> <br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    check_login()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f1&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>():<br>    check_login()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f2&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f3</span>():<br>    check_login()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f3&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f4</span>():<br>    check_login()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f4&#x27;</span>)复制Error复制成功...<br></code></pre></td></tr></table></figure><p>老大看了下Low BBB 的实现，嘴角漏出了一丝的欣慰的笑，语重心长的跟Low BBB聊了个天：</p><h5 id="老大说："><a href="#老大说：" class="headerlink" title="老大说："></a>老大说：</h5><p>写代码要遵循<code>开放封闭</code>原则，虽然在这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即：</p><ul><li>封闭：已实现的功能代码块</li><li>开放：对扩展开发</li></ul><p>如果将开放封闭原则应用在上述需求中，那么就不允许在函数<code>f1</code>、<code>f2</code>、<code>f3</code>、<code>f4</code>的内部进行修改代码，老板就给了Low BBB一个实现方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_login</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-comment"># 验证1</span><br>        <span class="hljs-comment"># 验证2</span><br>        <span class="hljs-comment"># 验证3</span><br>        func()<br>    <span class="hljs-keyword">return</span> inner<br> <br><span class="hljs-comment"># 在f1、f2、f3、f4函数定义之前多写一句话</span><br><span class="hljs-meta">@check_login</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f1&#x27;</span>)<br><span class="hljs-meta">@check_login</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f2&#x27;</span>)<br><span class="hljs-meta">@check_login</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f3</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f3&#x27;</span>)<br><span class="hljs-meta">@check_login</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f4</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f4&#x27;</span>)复制Error复制成功...<br></code></pre></td></tr></table></figure><p>对于上述代码，也是仅仅对基础平台的代码进行修改，就可以实现在其他人调用函数<code>f1</code>、 <code>f2</code>、<code>f3</code>、<code>f4</code> 之前都进行权限验证操作，并且其他业务部门无需做任何操作。</p><p>Low BBB心惊胆战的问了下，这段代码的内部执行原理是什么呢？</p><p>老大正要生气，突然Low BBB的手机掉到地上，恰巧屏保就是Low BBB的女友照片，老大一看，喜笑颜开，决定和Low BBB交个好朋友，将他所知道的全部告诉他。</p><h2 id="4-装饰器"><a href="#4-装饰器" class="headerlink" title="4. 装饰器"></a>4. 装饰器</h2><p>单独以函数<code>f1</code>为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_login</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-comment"># 验证1</span><br>        <span class="hljs-comment"># 验证2</span><br>        <span class="hljs-comment"># 验证3</span><br>        func()<br>    <span class="hljs-keyword">return</span> inner<br> <br><span class="hljs-meta">@check_login</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f1&#x27;</span>)复制Error复制成功...<br></code></pre></td></tr></table></figure><p>当Python解释器对上述代码运行时，会从上到下解释代码，步骤如下：</p><ol><li>遇到<code>def check_login(func): </code> 将<code>check_login</code>函数加载到内存</li><li>执行<code>@check_login</code></li></ol><p>没错， 从表面上看解释器仅仅会解释这两句代码，因为函数在 没有被调用之前其内部代码不会被执行。</p><p>从表面上看解释器着实会执行这两句，但是<code>@check_login</code>这一句代码里却有大文章， <code>@xxx</code> 是Python的一种语法糖（简单理解为令你很惊奇的功能）</p><h3 id="4-1-xxx实现过程"><a href="#4-1-xxx实现过程" class="headerlink" title="4.1 @xxx实现过程"></a>4.1 <code>@xxx</code>实现过程</h3><p>上例中<code>@check_login</code>内部会执行以下操作：</p><h4 id="步骤1：执行check-login函数"><a href="#步骤1：执行check-login函数" class="headerlink" title="[步骤1：执行check_login函数"></a>[步骤1：执行check_login函数</h4><p>执行check_login函数 ，并将 @check_login 下面的函数作为check_login函数的参数</p><p>即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@check_login</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():复制Error复制成功...<br></code></pre></td></tr></table></figure><p>等价于如下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">check_login(f1)复制Error复制成功...<br></code></pre></td></tr></table></figure><p>所以，内部就会去执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(): <br>    <span class="hljs-comment">#验证 1</span><br>    <span class="hljs-comment">#验证 2</span><br>    <span class="hljs-comment">#验证 3</span><br>    f1()    <span class="hljs-comment"># func是参数，此时 func 等于 f1 </span><br><span class="hljs-keyword">return</span> inner  <span class="hljs-comment"># 返回的 inner，inner代表的是函数，非执行函数 ,其实就是将原来的 f1 函数塞进另外一个函数中复制Error复制成功...</span><br></code></pre></td></tr></table></figure><h4 id="步骤2：f1-x3D-check-login的返回值"><a href="#步骤2：f1-x3D-check-login的返回值" class="headerlink" title="步骤2：f1 &#x3D; check_login的返回值"></a>步骤2：f1 &#x3D; check_login的返回值</h4><p>将执行完的<code>check_login</code> 函数返回值 赋值 给<code>@check_login </code>下面的函数的函数名<code>f1</code> 即将<code>check_login </code>的返回值再重新赋值给 <code>f1</code>，即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">新f1 = inner复制Error复制成功...<br></code></pre></td></tr></table></figure><p>所以，以后业务部门想要执行<code>f1</code>函数时，就会执行<code>新f1</code>函数，在<code>新f1</code>函数内部先执行验证，再执行原来的<code>f1</code>函数，然后将原来<code>f1</code> 函数的返回值返回给了业务调用者</p><p>如此一来， 即执行了验证的功能，又执行了原来<code>f1</code>函数的内容，并将原<code>f1</code>函数返回值 返回给业务调用着</p><h3 id="4-2-测试"><a href="#4-2-测试" class="headerlink" title="4.2 测试"></a>4.2 测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_login</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-comment"># 验证1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;admin&quot;</span> != <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入用户名:&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户名不正确&quot;</span><br>        <span class="hljs-comment"># 验证2</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;123456&quot;</span> != <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入密码:&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;密码不正确&quot;</span><br>        <span class="hljs-comment"># 验证3</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;7788&quot;</span> != <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入手机短信验证码:&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;验证码不正确&quot;</span><br><br>        func()<br><br>    <span class="hljs-keyword">return</span> inner<br><br><br><span class="hljs-meta">@check_login</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f1&#x27;</span>)<br><br><br>f1()  <span class="hljs-comment"># 调用f1函数</span><br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/3.png"></p><h3 id="4-3-研究实现-的功能"><a href="#4-3-研究实现-的功能" class="headerlink" title="4.3 研究实现@的功能"></a>4.3 研究实现<code>@</code>的功能</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_login</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-comment"># 验证1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;admin&quot;</span> != <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入用户名:&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户名不正确&quot;</span><br>        <span class="hljs-comment"># 验证2</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;123456&quot;</span> != <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入密码:&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;密码不正确&quot;</span><br>        <span class="hljs-comment"># 验证3</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;7788&quot;</span> != <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入手机短信验证码:&quot;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;验证码不正确&quot;</span><br><br>        func()<br><br>    <span class="hljs-keyword">return</span> inner<br><br><br><span class="hljs-comment"># @check_login</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f1&#x27;</span>)<br><br><span class="hljs-comment"># 下一行代码完成了第18行@check_login的作用</span><br>f1 = check_login(f1)<br><br>f1()  <span class="hljs-comment"># 调用f1函数复制Error复制成功...</span><br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/4.png"></p><p>Low BBB 你明白了吗？要是没明白的话，我晚上去你家帮你实现吧！！！</p><h3 id="4-4-使用-对函数装饰的时间"><a href="#4-4-使用-对函数装饰的时间" class="headerlink" title="4.4 使用@对函数装饰的时间"></a>4.4 使用<code>@</code>对函数装饰的时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">timefun</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----开始装饰----&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped_func</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----开始调用原函数----&quot;</span>)<br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----结束调用原函数----&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----完成装饰----&quot;</span>)<br>    <span class="hljs-keyword">return</span> wrapped_func<br><br><br><span class="hljs-meta">@timefun</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">helloworld</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;helloworld&quot;</span>)<br><br><br>helloworld()  <span class="hljs-comment"># 注意此时并没有调用函数helloworld，如果运行结果中出现了一些信息，则说明@timefun开始装饰</span><br>              <span class="hljs-comment"># 的时间是Python解释器在遇到那句代码时进行，而不是因为调用被装饰的函数 才开始装饰</span><br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/5.png"></p><h3 id="4-5-思考"><a href="#4-5-思考" class="headerlink" title="4.5 思考"></a>4.5 思考</h3><p>其实实现装饰器用到了闭包，只是将闭包中外部函数的返回值 给了 被装饰函数名字，从而修改了函数指向而已</p><p>那么，有个问题需要想想：在使用普通闭包 与 将闭包用作实现装饰器 时，有什么不同吗？</p><p>闭包例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do</span>(<span class="hljs-params">content</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(%s):%s&quot;</span> % (name, content))<br><br>    <span class="hljs-keyword">return</span> do<br><br><br>zhangsan = who(<span class="hljs-string">&quot;张三&quot;</span>)<br>lisi = who(<span class="hljs-string">&quot;李四&quot;</span>)<br><br>zhangsan(<span class="hljs-string">&quot;你努力了吗？&quot;</span>)<br>lisi(<span class="hljs-string">&quot;为啥努力！&quot;</span>)<br>zhangsan(<span class="hljs-string">&quot;你确定不要努力吗？&quot;</span>)<br>lisi(<span class="hljs-string">&quot;嗯，确定？&quot;</span>)<br>zhangsan(<span class="hljs-string">&quot;那可就不要要怪别人努力了啊&quot;</span>)<br>lisi(<span class="hljs-string">&quot;别人与我何关!&quot;</span>)<br>zhangsan(<span class="hljs-string">&quot;隔壁那户人家姓xxxx&quot;</span>)<br>lisi(<span class="hljs-string">&quot;( ⊙ o ⊙ )啊！&quot;</span>)<br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>装饰器例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>():<br>        ret = func()<br>        <span class="hljs-keyword">if</span> ret <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(ret , <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;log.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>                f.write(ret)<br><br>        <span class="hljs-keyword">return</span> ret<br><br>    <span class="hljs-keyword">return</span> call<br><br><br><span class="hljs-meta">@log</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_hello</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span><br><br><br><span class="hljs-built_in">print</span>(print_hello())<br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/6.png"></p><p>小总结：</p><ul><li>普通闭包：内部函数将使用的外部变量当做数据来用</li><li>将闭包当做装饰器：内部函数将使用的外部变量当做可调用的对象(例如函数)来调用</li><li>装饰器(decorator)功能<ul><li>引入日志</li><li>函数执行时间统计</li><li>执行函数前预备处理</li><li>执行函数后清理功能</li><li>权限校验等场景</li><li>缓存</li></ul></li></ul><h2 id="5-深入装饰器"><a href="#5-深入装饰器" class="headerlink" title="5. 深入装饰器"></a>5. 深入装饰器</h2><h3 id="5-1-对无参数的函数进行装饰"><a href="#5-1-对无参数的函数进行装饰" class="headerlink" title="5.1 对无参数的函数进行装饰"></a>5.1 对无参数的函数进行装饰</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime, sleep<br><br><span class="hljs-comment"># 定义一个闭包</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timefun</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped_func</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s called at %s&quot;</span> % (func.__name__, ctime()))<br>        func()<br>    <span class="hljs-keyword">return</span> wrapped_func<br><br><br><span class="hljs-meta">@timefun  </span><span class="hljs-comment"># 使用装饰器对foo进行装饰，此时相当于foo = timefun(foo)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am foo&quot;</span>)<br><br>foo()  <span class="hljs-comment"># 相当于调用的是wrapped_func函数</span><br>sleep(<span class="hljs-number">2</span>)<br>foo()  <span class="hljs-comment"># 相当于调用的是wrapped_func函数</span><br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/13.png"></p><p>上面代码理解装饰器执行行为可理解成</p><ol><li>&#96;&#96;&#96;<br>foo &#x3D; timefun(foo)<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br>   <span class="hljs-number">1.</span> foo先作为参数赋值给<span class="hljs-keyword">func</span>后，<span class="hljs-title function_">foo</span>接收指向<span class="hljs-title function_">timefun</span>返回的<span class="hljs-title function_">wrapped_func</span><br><br><span class="hljs-number">2.</span> 执行<br><br></code></pre></td></tr></table></figure>foo()<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>   <span class="hljs-number">1.</span> 调用foo()即等价调用wrapped_func()<br>   <span class="hljs-number">2.</span> 内部函数wrapped_func被引用，所以外部函数的func变量(自由变量)并没有释放<br>   <span class="hljs-number">3.</span> func里保存的是原foo函数对象<br><br>![](装饰器/<span class="hljs-number">14.</span>png)<br><br><span class="hljs-comment">### 5.2 对有参数的函数进行装饰</span><br><br>```python<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime, sleep<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timefun</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped_func</span>(<span class="hljs-params">a, b</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s called at %s&quot;</span> % (func.__name__, ctime()))<br>        <span class="hljs-built_in">print</span>(a, b)<br>        func(a, b)<br>    <span class="hljs-keyword">return</span> wrapped_func<br><br><span class="hljs-meta">@timefun</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(a+b)<br><br>foo(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br>sleep(<span class="hljs-number">2</span>)<br>foo(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)复制Error复制成功...<br></code></pre></td></tr></table></figure></li></ol><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/15.png"></p><h3 id="5-3-对带有不定长参数的函数进行装饰"><a href="#5-3-对带有不定长参数的函数进行装饰" class="headerlink" title="5.3 对带有不定长参数的函数进行装饰"></a>5.3 对带有不定长参数的函数进行装饰</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime, sleep<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timefun</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped_func</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-comment"># args=(3,5,7)</span><br>        <span class="hljs-comment"># kwargs = &#123;&#125;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s called at %s&quot;</span>%(func.__name__, ctime()))<br>        func(*args, **kwargs)  <span class="hljs-comment"># 对args,kwargs进行拆包，此时相当于func(3,5,7)</span><br>    <span class="hljs-keyword">return</span> wrapped_func<br><br><br><span class="hljs-meta">@timefun</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b, c</span>):<br>    <span class="hljs-comment"># a=3,b=5,c=7</span><br>    <span class="hljs-built_in">print</span>(a+b+c)  <span class="hljs-comment"># 15</span><br><br>foo(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>)  <span class="hljs-comment"># 将3，5，7这些未命名参数传递到第5行函数中，此时args用元组存储</span><br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/7.png"></p><h3 id="5-4-对带有return的函数进行装饰"><a href="#5-4-对带有return的函数进行装饰" class="headerlink" title="5.4 对带有return的函数进行装饰"></a>5.4 对带有<code>return</code>的函数进行装饰</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime, sleep<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timefun</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped_func</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s called at %s&quot;</span> % (func.__name__, ctime()))<br>        func()<br>    <span class="hljs-keyword">return</span> wrapped_func<br><br><br><span class="hljs-meta">@timefun</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am foo&quot;</span>)<br><br><br><span class="hljs-meta">@timefun</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_info</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;----hahah---&#x27;</span><br><br>foo()<br>sleep(<span class="hljs-number">2</span>)<br>foo()<br><br><span class="hljs-built_in">print</span>(get_info())  <span class="hljs-comment"># 可以看到这里并没有 get_info这个函数 返回的数据，因此这里有不完善的地方</span><br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>执行结果:</p><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/8.png"></p><p>如果修改装饰器为<code>return func()</code>，完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> ctime, sleep<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timefun</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped_func</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s called at %s&quot;</span> % (func.__name__, ctime()))<br>        <span class="hljs-comment"># 这里应该加上return ，及时func指向的函数没有返回值，那么默认也是None，</span><br>        <span class="hljs-comment"># 此时无非是return None而已，也是可以的</span><br>        <span class="hljs-keyword">return</span> func()<br>    <span class="hljs-keyword">return</span> wrapped_func<br><br><br><span class="hljs-meta">@timefun</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am foo&quot;</span>)<br><br><br><span class="hljs-meta">@timefun</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_info</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;----hahah---&#x27;</span><br><br>foo()<br>sleep(<span class="hljs-number">2</span>)<br>foo()<br><br><span class="hljs-built_in">print</span>(get_info())<br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/16.png"></p><p>小总结：</p><p>一般情况下为了让装饰器更通用，可以有<code>return</code>，即使这个被装饰的函数默认没有返回值也不会有问题，因为此时相当于<code>return None</code></p><h3 id="5-5-多个装饰器对同一个函数装饰"><a href="#5-5-多个装饰器对同一个函数装饰" class="headerlink" title="5.5 多个装饰器对同一个函数装饰"></a>5.5 多个装饰器对同一个函数装饰</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义函数：完成包裹数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">makeBold</span>(<span class="hljs-params">fn</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>():<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;b&gt;&quot;</span> + fn() + <span class="hljs-string">&quot;&lt;/b&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-comment"># 定义函数：完成包裹数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">makeItalic</span>(<span class="hljs-params">fn</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapped</span>():<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;i&gt;&quot;</span> + fn() + <span class="hljs-string">&quot;&lt;/i&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> wrapped<br><br><span class="hljs-meta">@makeBold</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world-1&quot;</span><br><br><span class="hljs-meta">@makeItalic</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world-2&quot;</span><br><br><span class="hljs-meta">@makeBold</span><br><span class="hljs-meta">@makeItalic</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test3</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world-3&quot;</span><br><br><span class="hljs-built_in">print</span>(test1())<br><span class="hljs-built_in">print</span>(test2())<br><span class="hljs-built_in">print</span>(test3())复制Error复制成功...<br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>hello world-1<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>hello world-2<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>hello world-3<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>复制Error复制成功...<br></code></pre></td></tr></table></figure><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/10.png"></p><h3 id="5-6-装饰器带参数"><a href="#5-6-装饰器带参数" class="headerlink" title="5.6 装饰器带参数"></a>5.6 装饰器带参数</h3><p>在原有装饰器的基础上，设置外部变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">call_out2</span>(<span class="hljs-params">timeout=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_out1</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">call</span>():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----1----&quot;</span>)<br>            time.sleep(timeout)<br>            ret = func()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----2----&quot;</span>)<br>            <span class="hljs-keyword">return</span> ret<br>        <span class="hljs-keyword">return</span> call<br>    <span class="hljs-keyword">return</span> call_out1<br><br><br><span class="hljs-comment"># 下面的装饰过程</span><br><span class="hljs-comment"># 1. 调用timefun_arg(&quot;itcast&quot;) 得到一个返回值，即time_fun</span><br><span class="hljs-comment"># 3. 然后执行time_fun(foo) 得到一个返回值，即wrapped_func</span><br><span class="hljs-comment"># 4. 让foo = wrapped_fun，即foo现在指向wrapped_func</span><br><span class="hljs-meta">@call_out2(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_hello</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span><br><br><br><span class="hljs-built_in">print</span>(print_hello())<br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>可以理解为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markup"># 1. 修改print_hello的指向<br>print_hello = call_out2(2)(print_hello)<br># 2. 调用print_hello指向的新的函数<br>print_hello()复制Error复制成功...<br></code></pre></td></tr></table></figure><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/11.png"></p><h3 id="5-7-用类当做装饰器"><a href="#5-7-用类当做装饰器" class="headerlink" title="5.7 用类当做装饰器"></a>5.7 用类当做装饰器</h3><p>装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重写了 <code>__call__()</code> 方法，那么这个对象就是callable的。</p><h3 id="5-7-1-直接调用实例对象"><a href="#5-7-1-直接调用实例对象" class="headerlink" title="5.7.1 直接调用实例对象"></a>5.7.1 直接调用实例对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;call me!&#x27;</span>)<br><br>t = Test()<br>t()  <span class="hljs-comment"># 因为创建t的类Test中实现了__call__方法，那么也就意味着可以直接调用这个实例对象复制Error复制成功...</span><br></code></pre></td></tr></table></figure><h3 id="5-7-2-使用类对函数进行装饰"><a href="#5-7-2-使用类对函数进行装饰" class="headerlink" title="5.7.2 使用类对函数进行装饰"></a>5.7.2 使用类对函数进行装饰</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, func</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---初始化---&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func name is %s&quot;</span> % func.__name__)<br>        self.__func = func<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---装饰器中的功能---&quot;</span>)<br>        self.__func()<br><br><br><span class="hljs-comment">#说明：</span><br><span class="hljs-comment">#1. 当用Test来装作装饰器对test函数进行装饰的时候，首先会创建Test的实例对象</span><br><span class="hljs-comment">#   并且会把test这个函数名当做参数传递到__init__方法中</span><br><span class="hljs-comment">#   即在__init__方法中的属性__func指向了test指向的函数</span><br><span class="hljs-comment">#2. test指向了用Test创建出来的实例对象</span><br><span class="hljs-comment">#3. 当在使用test()进行调用时，就相当于直接调用实例对象，因此会调用这个对象的__call__方法</span><br><span class="hljs-comment">#4. 为了能够在__call__方法中调用原来test指向的函数体，所以在__init__方法中就需要一个实例属性来保存这个函数体的引用</span><br><span class="hljs-comment">#   所以才有了self.__func = func这句代码，从而在调用__call__方法中能够调用到test之前的函数体</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----test---&quot;</span>)<br><br><br>test()  <span class="hljs-comment"># 如果把这句话注释，重新运行程序，依然会看到&quot;--初始化--&quot;</span><br>复制Error复制成功...<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/%E8%A3%85%E9%A5%B0%E5%99%A8/12.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ol><li>装饰器：能够快速将函数的指向修改，能够在不修改代码的前提下，给函数添加功能的方式</li><li>装饰器功能：给函数添加功能</li><li>特点：不修改原函数代码，还能添加功能；只能在原函数运行之前或者之后添加，不能在原函数运行一半时添加</li><li>实现过程：1. 将原函数的引用当做实参传递到闭包中 2. 修改原函数的指向为闭包中的内部函数</li><li>装饰器实际上用到了闭包，只不过在给外层函数传递参数时，传递的是需要被装饰的函数引用而已</li><li>装饰器还用到了引用，即在Python中，<code>a=xx</code>那么无论<code>xx</code>是列表、字典还是对象，一定是<code>a</code>指向它，而不是存储它</li></ol>]]></content>
    
    
    <categories>
      
      <category>python高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>装饰器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2022/05/03/%E9%97%AD%E5%8C%85/"/>
    <url>/2022/05/03/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1. 闭包"></a>1. 闭包</h2><h3 id="1-1-引用"><a href="#1-1-引用" class="headerlink" title="1.1 引用"></a>1.1 引用</h3><p>在python中一切皆引用，一切皆对象，其实一个函数也可以被引用</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--- in test func----&quot;</span>)<br><br><br>test()  <span class="hljs-comment"># 这是调用函数</span><br><br>ret = test  <span class="hljs-comment"># 用另外一个变量 复制了 test这个引用，导致ret变量也指向那个 函数代码块</span><br><br><span class="hljs-comment"># 下面输出的2个地址信息是相同的</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(ret))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(test))<br><br><span class="hljs-comment"># 通过引用调用函数</span><br>ret()<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/%E9%97%AD%E5%8C%85/1.png"></p><p>我们以可以看到，一个函数也是可以被引用的</p><h3 id="1-2-什么是闭包"><a href="#1-2-什么是闭包" class="headerlink" title="1.2 什么是闭包"></a>1.2 什么是闭包</h3><p>这是维基百科的定义</p><blockquote><p>在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 —— 维基百科<code>https://zh.wikipedia.org/wiki/闭包_(计算机科学)</code></p></blockquote><p>用比较直观的话来描述就是函数嵌套函数，外部函数的返回值是内部函数</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_printer</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printer</span>():<br>        <span class="hljs-built_in">print</span>(msg)<br>    <span class="hljs-keyword">return</span> printer<br><br>printer = make_printer(<span class="hljs-string">&#x27;今天是个好日子&#x27;</span>)<br>printer()<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E9%97%AD%E5%8C%85/2.png"></p><p>注意：</p><p>上面的代码<code>return</code>的是方法名，并不带<code>()</code>因为我们要拿到的是内部方法的引用，上面的代码中，<code>printer</code>拿到了<code>make_printer</code>的返回值也就是内部方法<code>printer</code>的引用，这时我们就可以调用内部方法。</p><h2 id="2-闭包案例"><a href="#2-闭包案例" class="headerlink" title="2. 闭包案例"></a>2. 闭包案例</h2><h3 id="2-1-案例一（简单的数值计算）"><a href="#2-1-案例一（简单的数值计算）" class="headerlink" title="2.1 案例一（简单的数值计算）"></a>2.1 案例一（简单的数值计算）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">number</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_in</span>(<span class="hljs-params">number_in</span>):<br>        <span class="hljs-keyword">return</span> number+number_in<br>    <span class="hljs-keyword">return</span> test_in<br><br>ret = test(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(ret(<span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="/%E9%97%AD%E5%8C%85/3.png"></p><h3 id="2-2-案例二-（计算坐标）"><a href="#2-2-案例二-（计算坐标）" class="headerlink" title="2.2 案例二 （计算坐标）"></a>2.2 案例二 （计算坐标）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">line_conf</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">line</span>(<span class="hljs-params">x</span>):<br>        <span class="hljs-keyword">return</span> a*x + b<br>    <span class="hljs-keyword">return</span> line<br><br>line1 = line_conf(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>line2 = line_conf(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(line1(<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(line2(<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="/%E9%97%AD%E5%8C%85/4.png"></p><p>这个例子中，函数<code>line</code>与变量<code>a</code>,<code>b</code>构成闭包。</p><p>在创建闭包的时候，我们通过<code>line_conf</code>的参数<code>a</code>,<code>b</code>设置了这两个变量的取值，这样就确定了函数的最终形式(<code>y = x + 1</code>和<code>y = 4x + 5</code>)。</p><p>如果需要修改这条线的信息，只需要变换参数<code>a</code>,<code>b</code>，就可以获得不同的直线表达函数。</p><p>由此，我们可以看到，闭包也具有提高代码可复用性的作用</p><p>如果没有闭包，我们需要每次创建直线函数的时候同时说明<code>a</code>,<code>b</code>,<code>x</code>。这样，我们就需要更多的参数传递，也减少了代码的可移植性</p><h2 id="3-注意点"><a href="#3-注意点" class="headerlink" title="3.注意点"></a>3.注意点</h2><h3 id="3-1-使用闭包应注意的问题"><a href="#3-1-使用闭包应注意的问题" class="headerlink" title="3.1 使用闭包应注意的问题"></a>3.1 使用闭包应注意的问题</h3><p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。因此可以手动解除对匿名函数的引用，以便释放内存。</p><h3 id="3-2-修改外部函数中的变量"><a href="#3-2-修改外部函数中的变量" class="headerlink" title="3.2 修改外部函数中的变量"></a>3.2 修改外部函数中的变量</h3><p>可以使用nonlocal获取外部变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">start=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_one</span>():<br>        <span class="hljs-keyword">nonlocal</span> start<br>        start += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> start<br>    <span class="hljs-keyword">return</span> add_one<br><br>c1 = counter(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 创建一个闭包</span><br><span class="hljs-built_in">print</span>(c1())<br><span class="hljs-built_in">print</span>(c1())<br><br>c2 = counter(<span class="hljs-number">50</span>)  <span class="hljs-comment"># 创建另外一个闭包</span><br><span class="hljs-built_in">print</span>(c2())<br><span class="hljs-built_in">print</span>(c2())<br><br><span class="hljs-built_in">print</span>(c1())<br><span class="hljs-built_in">print</span>(c1())<br><br><span class="hljs-built_in">print</span>(c2())<br><span class="hljs-built_in">print</span>(c2())<br><br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="/%E9%97%AD%E5%8C%85/5.png"></p><h3 id="3-3-多个闭包"><a href="#3-3-多个闭包" class="headerlink" title="3.3 多个闭包"></a>3.3 多个闭包</h3><p>如上面的代码中，调用了2次<code>counter</code>，也就意味着创建了2个闭包，并且每个闭包之间没有任何关系。</p><p>大家是否有种感觉，好像闭包与对象有些类似。确实是这样的，对象其实可通俗的理解为数据(属性)+功能(方法)，而闭包也可以理解为数据+功能，只不过此时数据是外部函数中的那些局部变量或者形参，而功能则是内部函数。对象适合完成较为复杂的功能，而闭包则更轻量</p><h2 id="4-闭包应用"><a href="#4-闭包应用" class="headerlink" title="4. 闭包应用"></a>4. 闭包应用</h2><p>下面应用案例是理解闭包的经典题目，模拟了一个人站在原点，然后向X、Y轴进行移动，每次移动后及时打印当前的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>():<br>    pos = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 坐标系统原点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">player</span>(<span class="hljs-params">direction, step</span>):<br>        <span class="hljs-comment"># 这里应该首先判断参数direction,step的合法性，比如direction不能斜着走，step不能为负等</span><br>        <span class="hljs-comment"># 然后还要对新生成的x，y坐标的合法性进行判断处理，这里主要是想介绍闭包，就不详细写了</span><br>        new_x = pos[<span class="hljs-number">0</span>] + direction[<span class="hljs-number">0</span>] * step<br>        new_y = pos[<span class="hljs-number">1</span>] + direction[<span class="hljs-number">1</span>] * step<br>        pos[<span class="hljs-number">0</span>] = new_x<br>        pos[<span class="hljs-number">1</span>] = new_y<br>        <span class="hljs-keyword">return</span> pos<br><br>    <span class="hljs-keyword">return</span> player<br><br><br>player = create()  <span class="hljs-comment"># 创建棋子player，起点为原点</span><br><span class="hljs-built_in">print</span>(player([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], <span class="hljs-number">10</span>))  <span class="hljs-comment"># 向x轴正方向移动10步</span><br><span class="hljs-built_in">print</span>(player([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-number">20</span>))  <span class="hljs-comment"># 向y轴正方向移动20步</span><br><span class="hljs-built_in">print</span>(player([-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], <span class="hljs-number">10</span>))  <span class="hljs-comment"># 向x轴负方向移动10步</span><br><br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E9%97%AD%E5%8C%85/6.png"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol><li>闭包定义是在函数内再嵌套函数</li><li>闭包是可以访问另一个函数局部作用域中变量的函数</li><li>闭包可以读取另外一个函数内部的变量</li><li>闭包可以让参数和变量不会被垃圾回收机制回收，始终保持在内存中（而普通的函数调用结束后 会被Python解释器自动释放局部变量）</li></ol>]]></content>
    
    
    <categories>
      
      <category>python高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>闭包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成器</title>
    <link href="/2022/05/03/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2022/05/03/%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-生成器"><a href="#1-生成器" class="headerlink" title="1.生成器"></a>1.生成器</h2><h3 id="1-1什么是生成器"><a href="#1-1什么是生成器" class="headerlink" title="1.1什么是生成器"></a>1.1什么是生成器</h3><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的<code>list</code>，从而节省大量的空间。</p><p>通俗的理解：</p><p>在Python中，这种一边循环一边计算的机制，称为生成器：generator</p><h3 id="1-2-生成器"><a href="#1-2-生成器" class="headerlink" title="1.2 生成器"></a>1.2 生成器</h3><p>其实利用迭代器，我们也可以在每次迭代获取数据（通过<code>next()</code>方法）时按照特定的规律进行生成。</p><p>但是在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。</p><p>为了达到记录当前状态，并配合<code>next()</code>函数进行迭代使用，</p><p>简言之，迭代器是可以实现在循环的过程中生成数据的，但是稍稍有些复杂</p><p>有一个能具有迭代器的功能，且比它更加简单的方式：生成器(<code>generator</code>)</p><p>生成器是一类特殊的迭代器</p><h3 id="1-3创建一个生成器"><a href="#1-3创建一个生成器" class="headerlink" title="1.3创建一个生成器"></a>1.3创建一个生成器</h3><ul><li><p>方法一</p><p>第一种方法很简单，只需要把一个列表生成式的<code>[]</code>改成’()’就可</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs python">nums = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(nums))<br><span class="hljs-built_in">print</span>(nums)<br><br>nums2 = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(nums2))<br><span class="hljs-built_in">print</span>(nums2)<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E7%94%9F%E6%88%90%E5%99%A8/1.png"></p><p>说明：</p><ol><li>区别在于最外层<code>[]</code>和<code>()</code>，nums是一个列表，而nums2是一个生成器</li><li>可以直接打印出列表<code>nums</code>的每一个元素，而对于生成器<code>nums2</code>，我们可以按照迭代器的使用方法来使用，即可以通过<code>next()</code>函数、<code>for</code>循环、<code>list()</code>等方法使用</li></ol></li><li><p>方法二</p><p><code>generator</code>功能十分强大</p><p>我们使用不同的方法来实现斐波那契数列进行比较</p><blockquote><p><strong>斐波那契数列</strong>指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……..</p><p>这个数列从第3项开始，每一项都等于前两项之和。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">nums1 = <span class="hljs-number">1</span><br>nums2 = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(nums1)<br><br>nums1, nums2 = nums2, nums1 + nums2<br><span class="hljs-built_in">print</span>(nums1)<br><br>nums1, nums2 = nums2, nums1 + nums2<br><span class="hljs-built_in">print</span>(nums1)<br><br>nums1, nums2 = nums2, nums1 + nums2<br><span class="hljs-built_in">print</span>(nums1)<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E7%94%9F%E6%88%90%E5%99%A8/2.png"></p><p>下面使用迭代器来实现一个斐波那契数列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FibIterator</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.num1 = <span class="hljs-number">1</span><br>        self.num2 = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        temp = self.num1<br>        self.num1, self.num2 = self.num2, self.num1 + self.num2<br>        <span class="hljs-keyword">return</span> temp<br><br>fib = FibIterator()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib))<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E7%94%9F%E6%88%90%E5%99%A8/3.png"></p><p>使用迭代器可以实现但是略显麻烦，下面是使用生成器的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_generator</span>():<br>    num1 = <span class="hljs-number">1</span><br>    num2 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        temp = num1<br>        num1, num2 = num2, num1 + num2<br>        <span class="hljs-keyword">yield</span> temp<br><br><br>fib = fib_generator()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(fib))<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E7%94%9F%E6%88%90%E5%99%A8/4.png"></p><p>在使用生成器实现的方式中，我们将原本在迭代器<code>__next__</code>方法中实现的基本逻辑放到一个函数中来实现，但是将每次迭代返回数值的<code>return</code>换成了<code>yield</code>，此时新定义的函数便不再是函数，而是一个<strong>生成器</strong>了</p><p>简单来说：只要在<code>def函数</code>中有<code>yield</code>关键字的 就称为 生成器</p><p>此时按照调用函数的方式( <code>fib = fib_generator()</code> )就不再是执行函数体了，而是会返回一个生成器对象，然后就可以按照使用迭代器(因为生成器是一种特殊的迭代器)的方式来使用生成器了</p></li></ul><h2 id="2-yield关键字"><a href="#2-yield关键字" class="headerlink" title="2.yield关键字"></a>2.<code>yield</code>关键字</h2><p>上面的代码，在函数中使用了<code>yield</code>关键字</p><p>说明：</p><ol><li>只要有<code>yield</code>关键字，那么虽然看上去是调用函数，实际上已经变成了创建一个 生成器对象</li><li>通过<code>next</code>调用 生成器，可以让 这个带有<code>yield</code>的方法代码块，开始执行<ul><li>如果是第一次执行，则从<code>def</code>代码块的开始部分执行，直到遇到<code>yield</code>为止，并且把<code>yield</code>关键字后的数值返回，当做<code>next()</code>的返回值</li><li>如果不是第一次执行，则从上一次暂停的位置执行(即从上一次<code>yield</code>关键字的下一个语句开始执行)，直到遇到下一次<code>yield</code>为止，并且把<code>yield</code>关键字后的数值返回，当做<code>next()</code>的返回值</li></ul></li></ol><p>更好的理解带有<code>yield</code>关键字的函数，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib_generator</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---1---&quot;</span>)<br>    num1 = <span class="hljs-number">1</span><br>    num2 = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---2---&quot;</span>)<br>        temp_num = num1<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---3---&quot;</span>)<br>        num1, num2 = num2, num1+num2<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---4---&quot;</span>)<br>        <span class="hljs-keyword">yield</span> temp_num<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---5---&quot;</span>)<br><br>fib = fib_generator()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行第1次的next函数---开始--&quot;</span>)<br>num = <span class="hljs-built_in">next</span>(fib)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行第1次的next函数---结束--&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打印第1次next返回的结果--开始--&quot;</span>)<br><span class="hljs-built_in">print</span>(num)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打印第1次next返回的结果--结束--&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行第2次的next函数---开始--&quot;</span>)<br>num = <span class="hljs-built_in">next</span>(fib)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行第2次的next函数---结束--&quot;</span>)<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打印第2次next返回的结果--开始--&quot;</span>)<br><span class="hljs-built_in">print</span>(num)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;打印第2次next返回的结果--结束--&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="/%E7%94%9F%E6%88%90%E5%99%A8/5.png"></p><p>注意：</p><ol><li><p>要知道一个<code>def</code>代码块，只要有<code>yield</code>就不再是函数，而是生成器</p></li><li><p>要知道调用<code>def</code>代码块(普通函数)与调用带有<code>yield</code>的<code>def</code>代码块(生成器)的调用方式不同</p></li><li><p>要注意<code>return</code>与<code>yield</code>的功能也不同</p><ul><li><p><code>return</code>接收一个函数，且有返回值</p></li><li><p><code>yield</code>暂停执行一个函数，且有返回值</p></li></ul></li></ol><h2 id="3-使用send唤醒"><a href="#3-使用send唤醒" class="headerlink" title="3.使用send唤醒"></a>3.使用send唤醒</h2><p>我们除了可以使用<code>next()</code>函数来唤醒，让生成器继续执行外，还可以使用<code>send()</code>函数来唤醒执行。</p><p>使用<code>send()</code>函数的一个好处是：可以在唤醒的同时向断点处传入一个附加数据</p><h3 id="3-1测试send"><a href="#3-1测试send" class="headerlink" title="3.1测试send"></a>3.1测试<code>send</code></h3><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator_test</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--1--&quot;</span>)<br>        num = <span class="hljs-keyword">yield</span> <span class="hljs-number">100</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--2--&quot;</span>, <span class="hljs-string">&quot;num=&quot;</span>, num)<br><br><br>g = generator_test()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E7%94%9F%E6%88%90%E5%99%A8/6.png"></p><p>我们可以看到num是没有值的</p><p>如果我们使用<code>send</code>唤醒，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generator_test</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--1--&quot;</span>)<br>        num = <span class="hljs-keyword">yield</span> <span class="hljs-number">100</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--2--&quot;</span>, <span class="hljs-string">&quot;num=&quot;</span>, num)<br><br><br>g = generator_test()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(g.send(<span class="hljs-number">22</span>))<br></code></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="/%E7%94%9F%E6%88%90%E5%99%A8/7.png"></p><p>注意send是不可以传递空值的这样会报错</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>使用了<code>yield</code>关键字的函数不再是函数，而是生成器</p></li><li><p><code>yield</code>关键字有两点作用：</p><ul><li><p>保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起</p></li><li><p>将<code>yield</code>关键字后面表达式的值作为返回值返回，此时可以理解为起到了<code>return</code>的作用</p></li></ul></li><li><p>可以使用<code>next()</code>函数让生成器从断点处继续执行，即唤醒生成器（函数）</p></li><li><p>Python3中的生成器可以使用<code>return</code>返回最终运行的返回值</p></li><li><p>生成器是这样一个函数，它记住上一次返回时在函数体中的位置。对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。生成器不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造（在命令式编程中，这种构造不只是数据值）中的位置。</p></li><li><p>生成器的特点：</p><ol><li>存储的是生成数据的方式（即算法），而不是存储生成的数据，因此节约内存</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>python高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迭代器</title>
    <link href="/2022/05/03/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2022/05/03/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是迭代"><a href="#1-什么是迭代" class="headerlink" title="1. 什么是迭代"></a>1. 什么是迭代</h2><p>迭代时访问集合元素的一种方式</p><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs python">nums = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]<br><br><span class="hljs-comment"># 可以通过for循环将nums列表中的每个数据依次获取</span><br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<br>    <span class="hljs-built_in">print</span>(num)<br><br><br>name = <span class="hljs-string">&quot;teacher&quot;</span><br><br><span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> name:<br>    <span class="hljs-built_in">print</span>(temp)<br><br></code></pre></td></tr></table></figure><p>运行效果</p><p><img src="/%E8%BF%AD%E4%BB%A3%E5%99%A8/image-20190226201002936.png"></p><h2 id="2-可迭代对象"><a href="#2-可迭代对象" class="headerlink" title="2. 可迭代对象"></a>2. 可迭代对象</h2><p>我们可以通俗地认为：</p><blockquote><p><strong>只要是可以通过for…in…的形式进行遍历的，那么这个数据类型就是可以迭代的</strong></p></blockquote><p>在python中可迭代的数据类型有：</p><ul><li>列表</li><li>元组</li><li>字典</li><li>字符串</li></ul><p>不可迭代的数据类型有：</p><ul><li>整形</li><li>浮点型</li></ul><h2 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h2><p>迭代器是一个可以记住遍历位置的对象。迭代器对象从第一个元素开始访问，直到所有的元素访问结束。迭代器只能往前不能后退。</p><h3 id="3-1-可迭代对象的本质"><a href="#3-1-可迭代对象的本质" class="headerlink" title="3.1 可迭代对象的本质"></a>3.1 可迭代对象的本质</h3><p>分析 可迭代对象 进行迭代的过程，发现每迭代一次（即在<code>for...in...</code>中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。</p><p>那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(Iterator)</p><p>可迭代对象的本质就是可以向我们提供一个这样的中间“人”，即迭代器帮助我们对其进行迭代遍历使用。</p><p><code>list</code>、<code>tuple</code>等都是可迭代对象，我们可以通过<code>iter()</code>函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用<code>next()</code>函数来获取下一条数据。</p><h3 id="3-2-获取可迭代对象的迭代器"><a href="#3-2-获取可迭代对象的迭代器" class="headerlink" title="3.2 获取可迭代对象的迭代器"></a>3.2 获取可迭代对象的迭代器</h3><p>我们可以通过<code>iter</code>方法获取可迭代对象的迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br>nums = [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(nums))<br>nums_iter = <span class="hljs-built_in">iter</span>(nums)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(nums_iter))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(nums,Iterator))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(nums_iter,Iterator))<br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E8%BF%AD%E4%BB%A3%E5%99%A8/2.png"></p><p>可以看到<code>list</code>是一个可迭代对象，但并不是一个迭代器，使用<code>iter</code>方法可以获取他的迭代器。</p><h3 id="3-3-获取迭代器的数据"><a href="#3-3-获取迭代器的数据" class="headerlink" title="3.3 获取迭代器的数据"></a>3.3 获取迭代器的数据</h3><p>此时我们可以通过next方法获取迭代器数据</p><p>测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><br><br>nums = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]<br>nums_iter = <span class="hljs-built_in">iter</span>(nums)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nums&quot;</span>, <span class="hljs-built_in">isinstance</span>(nums, Iterator))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nums_iter&quot;</span>, <span class="hljs-built_in">isinstance</span>(nums_iter, Iterator))<br><br><br>num1 = <span class="hljs-built_in">next</span>(nums_iter)<br><span class="hljs-built_in">print</span>(num1)<br><br>num2 = <span class="hljs-built_in">next</span>(nums_iter)<br><span class="hljs-built_in">print</span>(num2)<br><br>num3 = <span class="hljs-built_in">next</span>(nums_iter)<br><span class="hljs-built_in">print</span>(num3)<br><br>num4 = <span class="hljs-built_in">next</span>(nums_iter)<br><span class="hljs-built_in">print</span>(num4)<br><br></code></pre></td></tr></table></figure><h3 id="3-4-StopIteration异常"><a href="#3-4-StopIteration异常" class="headerlink" title="3.4 StopIteration异常"></a>3.4 StopIteration异常</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><br><br>nums = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]<br>nums_iter = <span class="hljs-built_in">iter</span>(nums)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nums&quot;</span>, <span class="hljs-built_in">isinstance</span>(nums, Iterator))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nums_iter&quot;</span>, <span class="hljs-built_in">isinstance</span>(nums_iter, Iterator))<br><br><br>num1 = <span class="hljs-built_in">next</span>(nums_iter)<br><span class="hljs-built_in">print</span>(num1)<br><br>num2 = <span class="hljs-built_in">next</span>(nums_iter)<br><span class="hljs-built_in">print</span>(num2)<br><br>num3 = <span class="hljs-built_in">next</span>(nums_iter)<br><span class="hljs-built_in">print</span>(num3)<br><br>num4 = <span class="hljs-built_in">next</span>(nums_iter)<br><span class="hljs-built_in">print</span>(num4)<br><br>num5 = <span class="hljs-built_in">next</span>(nums_iter)  <span class="hljs-comment"># 这里会产生异常</span><br><span class="hljs-built_in">print</span>(num5)<br><br></code></pre></td></tr></table></figure><p>此时<code>nums</code>列表中只有4个数据，所以第五次调用<code>next()</code>方法就会产生异常，我们使用<code>try...except...</code>即可解决。</p><h2 id="4-自定义迭代器"><a href="#4-自定义迭代器" class="headerlink" title="4. 自定义迭代器"></a>4. 自定义迭代器</h2><ul><li><code>__iter__</code>方法</li><li><code>__next__</code>方法</li></ul><h3 id="4-1-iter-方法"><a href="#4-1-iter-方法" class="headerlink" title="4.1 __iter__方法"></a>4.1 <code>__iter__</code>方法</h3><blockquote><p>只要在类中，定义了<code>__iter__</code>方法，那么这个类就是可迭代对象</p></blockquote><p>测试代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.container = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, item</span>):<br>        self.container.append(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>mylist = MyList()<br>mylist.add(<span class="hljs-number">11</span>)<br>mylist.add(<span class="hljs-number">22</span>)<br>mylist.add(<span class="hljs-number">33</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mylist是否是可以迭代对象&quot;</span>, <span class="hljs-built_in">isinstance</span>(mylist, Iterable))<br><br><span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> mylist:<br>    <span class="hljs-built_in">print</span>(temp)<br><br></code></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/%E8%BF%AD%E4%BB%A3%E5%99%A8/3.png"></p><p>可以看出一个类只要有<code>__iter__</code>方法，那么这个类就是可迭代对象</p><p>当我们调用<code>iter()</code>函数提取一个可迭代对象的迭代器时，实际上就会调用<code>__iter__</code>方法，并返回迭代器。</p><h3 id="4-2-next-方法"><a href="#4-2-next-方法" class="headerlink" title="4.2 __next__方法"></a>4.2 <code>__next__</code>方法</h3><p>当我们对迭代器使用<code>next()</code>函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。</p><p>实际上，在使用<code>next()</code>函数的时候，调用的就是迭代器对象的<code>__next__</code>方法（Python3中是对象的<code>__next__</code>方法，Python2中是对象的<code>next()</code>方法）。</p><p>所以，我们要想构造一个迭代器，就要实现它的<code>__next__</code>方法。</p><p>但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现<code>__iter__</code>方法，而<code>__iter__</code>方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的<code>__iter__</code>方法返回自身即可。</p><p>一个实现了<code>__iter__</code>方法和<code>__next__</code>方法的对象，就是迭代器</p><p>我们可以通过<code>isinstance()</code>判断一个对象是否是迭代器对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">In [<span class="hljs-number">56</span>]: <span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><br>In [<span class="hljs-number">57</span>]: <span class="hljs-built_in">isinstance</span>([], Iterator)<br>Out[<span class="hljs-number">57</span>]: <span class="hljs-literal">False</span><br><br>In [<span class="hljs-number">58</span>]: <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">iter</span>([]), Iterator)<br>Out[<span class="hljs-number">58</span>]: <span class="hljs-literal">True</span><br><br>In [<span class="hljs-number">59</span>]: <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">iter</span>(<span class="hljs-string">&quot;abc&quot;</span>), Iterator)<br>Out[<span class="hljs-number">59</span>]: <span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure><h3 id="4-3-实现一个迭代器"><a href="#4-3-实现一个迭代器" class="headerlink" title="4.3 实现一个迭代器"></a>4.3 实现一个迭代器</h3><p>此时，我们实现一个类的<code>__next__</code>方法和<code>__iter__</code>方法即可实现一个迭代器</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyIterator</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.mylist = []<br>        <span class="hljs-comment"># current用来记录当前访问到的位置</span><br>        self.current = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.current &lt; <span class="hljs-built_in">len</span>(self.mylist):<br>            item = self.mylist[self.current]<br>            self.current += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> item<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> StopIteration<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, val</span>):<br>        self.mylist.append(val)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    mylist = MyIterator()<br>    mylist.add(<span class="hljs-number">1</span>)<br>    mylist.add(<span class="hljs-number">2</span>)<br>    mylist.add(<span class="hljs-number">3</span>)<br>    mylist.add(<span class="hljs-number">4</span>)<br>    mylist.add(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> mylist:<br>        <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/%E8%BF%AD%E4%BB%A3%E5%99%A8/4.png"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><ul><li>凡是可作用于<code>for </code>循环的对象都是<code> Iterable</code> 类型；</li><li>凡是可作用于 <code>next()</code> 函数的对象都是<code> Iterator</code> 类型</li><li>集合数据类型如<code> list</code> 、<code>dict</code>、<code>str</code>等是 <code>Iterable </code>但不是<code>Iterator</code>，不过可以通过 <code>iter() </code>函数获得一个 <code>Iterator </code>对象</li></ul>]]></content>
    
    
    <categories>
      
      <category>python高级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>迭代器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题</title>
    <link href="/2022/05/01/Fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2022/05/01/Fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="这是第一篇博客"><a href="#这是第一篇博客" class="headerlink" title="这是第一篇博客"></a>这是第一篇博客</h2><p>上周用Hexo搭了个博客，今天突发奇想换个主题，结果改配置文件的时候不知道动了哪个地方的代码，自己也没备份，直接寄，全部推倒重来，给我整麻了</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>看看能不能坚持写作，记录一下自己学到的东西</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fluid主题</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/01/hello-world/"/>
    <url>/2022/05/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
